<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rompecabezas Jigsaw</title>
  <style>
    body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #222; }
    canvas { touch-action: none; background: #333; border: 2px solid #fff; }
  </style>
</head>
<body>
  <canvas id="puzzle" width="512" height="512"></canvas>

  <script>
    const canvas = document.getElementById("puzzle");
    const ctx = canvas.getContext("2d");
    const image = new Image();
    image.src = "./IMG-20250422-WA0005.jpg";

    const rows = 4, cols = 4;
    const pieceSize = 128;
    const tabSize = pieceSize / 4;
    const pieces = [];
    const tabsMap = Array.from({ length: cols }, () => Array(rows).fill(null));

    const rand = () => Math.random() > 0.5 ? 1 : -1;

    function createPath(x, y, col, row, size, tabs) {
      const s = size;
      const path = new Path2D();
      path.moveTo(x, y);

      // TOP
      if (tabs.top === 0) {
        path.lineTo(x + s, y);
      } else {
        const dir = tabs.top;
        const mid = x + s / 2;
        path.lineTo(mid - tabSize, y);
        path.bezierCurveTo(mid - tabSize / 2, y - dir * tabSize, mid + tabSize / 2, y - dir * tabSize, mid + tabSize, y);
        path.lineTo(x + s, y);
      }

      // RIGHT
      if (tabs.right === 0) {
        path.lineTo(x + s, y + s);
      } else {
        const dir = tabs.right;
        const mid = y + s / 2;
        path.lineTo(x + s, mid - tabSize);
        path.bezierCurveTo(x + s + dir * tabSize, mid - tabSize / 2, x + s + dir * tabSize, mid + tabSize / 2, x + s, mid + tabSize);
        path.lineTo(x + s, y + s);
      }

      // BOTTOM
      if (tabs.bottom === 0) {
        path.lineTo(x, y + s);
      } else {
        const dir = tabs.bottom;
        const mid = x + s / 2;
        path.lineTo(mid + tabSize, y + s);
        path.bezierCurveTo(mid + tabSize / 2, y + s + dir * tabSize, mid - tabSize / 2, y + s + dir * tabSize, mid - tabSize, y + s);
        path.lineTo(x, y + s);
      }

      // LEFT
      if (tabs.left === 0) {
        path.lineTo(x, y);
      } else {
        const dir = tabs.left;
        const mid = y + s / 2;
        path.lineTo(x, mid + tabSize);
        path.bezierCurveTo(x - dir * tabSize, mid + tabSize / 2, x - dir * tabSize, mid - tabSize / 2, x, mid - tabSize);
        path.lineTo(x, y);
      }

      path.closePath();
      return path;
    }

    class Piece {
      constructor(i, j, tabs) {
        this.col = i;
        this.row = j;
        this.correctX = i * pieceSize;
        this.correctY = j * pieceSize;
        this.x = Math.random() * (canvas.width - pieceSize);
        this.y = Math.random() * (canvas.height - pieceSize);
        this.tabs = tabs;
        this.dragging = false;
      }

      draw(context) {
        const extra = tabSize;
        const sx = this.col * pieceSize - extra;
        const sy = this.row * pieceSize - extra;
        const sw = pieceSize + extra * 2;
        const sh = pieceSize + extra * 2;

        const dx = this.x - extra;
        const dy = this.y - extra;
        const dw = sw;
        const dh = sh;

        const path = createPath(this.x, this.y, this.col, this.row, pieceSize, this.tabs);
        context.save();
        context.clip(path);
        context.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
        context.restore();

        context.strokeStyle = "white";
        context.lineWidth = 2;
        context.stroke(path);
      }

      isCloseToCorrect() {
        return Math.abs(this.x - this.correctX) < 10 && Math.abs(this.y - this.correctY) < 10;
      }

      snapToPlace() {
        this.x = this.correctX;
        this.y = this.correctY;
      }

      contains(x, y) {
        const path = createPath(this.x, this.y, this.col, this.row, pieceSize, this.tabs);
        return ctx.isPointInPath(path, x, y);
      }
    }

    let currentPiece = null;
    let offsetX = 0, offsetY = 0;

    image.onload = () => {
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          const tabs = {
            top: j === 0 ? 0 : -tabsMap[i][j - 1].bottom,
            left: i === 0 ? 0 : -tabsMap[i - 1][j].right,
            bottom: j === rows - 1 ? 0 : rand(),
            right: i === cols - 1 ? 0 : rand()
          };
          tabsMap[i][j] = tabs;
        }
      }

      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          pieces.push(new Piece(i, j, tabsMap[i][j]));
        }
      }

      drawAll();
    };

    function drawAll() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let p of pieces) p.draw(ctx);
    }

    function getPieceAt(x, y) {
      for (let i = pieces.length - 1; i >= 0; i--) {
        const p = pieces[i];
        if (p.contains(x, y)) {
          return p;
        }
      }
      return null;
    }

    canvas.addEventListener("pointerdown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      currentPiece = getPieceAt(x, y);
      if (currentPiece) {
        offsetX = x - currentPiece.x;
        offsetY = y - currentPiece.y;
        pieces.splice(pieces.indexOf(currentPiece), 1);
        pieces.push(currentPiece);
        currentPiece.dragging = true;
      }
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!currentPiece) return;
      const rect = canvas.getBoundingClientRect();
      currentPiece.x = e.clientX - rect.left - offsetX;
      currentPiece.y = e.clientY - rect.top - offsetY;
      drawAll();
    });

    canvas.addEventListener("pointerup", () => {
      if (!currentPiece) return;
      currentPiece.dragging = false;
      if (currentPiece.isCloseToCorrect()) {
        currentPiece.snapToPlace();
      }
      currentPiece = null;
      drawAll();
    });
  </script>
</body>
</html>
